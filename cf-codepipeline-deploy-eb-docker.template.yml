AWSTemplateFormatVersion: 2010-09-09

# This is a  codepipeline demo that 
# 1) grabs code from GitHub on change 
# 2) builds, dockerizes, and tests a NodeJS app. 
# 3) Stores image in ECR
# 4) deploys it to ElasticBeanstalk

# TO RUN THIS:  You'll need a GitHub Repository, and a GitHub OAuthToken.
# To make a GitHub OAuthToken, go to GitHub / Settings / Personal Access Tokens
# The default value you see here will work only if you prepend it with a '0'.
# You will also need an ECR registry containing the image you want to deploy, at least the initial copy of it.  This will be updated by the pipeline.

Metadata:
  # Controlling the order of the parameters on the CloudFormation page;
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: The location of source code
        Parameters:
          - GitHubRepository
          - GitHubOAuthToken
      - Label:
          default: Other
        Parameters:
          - DockerImageName
          - CodePipelineBucketPrefix

Parameters:
  GitHubRepository:
    Type: String
    Default:  kennyk65/docker-react/master
    Description:  The owner / repository / branch that you want to pull from.

  GitHubOAuthToken:
    Type: String
    Default:  b45b4b39fe35179592ceb5259c481b05a0eb27d
    Description:  CodePipeline sources require an OAuthToken, even if they are public.  To make one go to GitHub / Settings / Personal Access Tokens 

  DockerImageName:
    Description:  The label of the image to be created and deployed to Beanstalk. 
    Type: String
    Default:  docker-react

  CodePipelineBucketPrefix:
    Description: CodePipeline needs a utility bucket for its internal use.  Specify the prefix for the bucket name.  You'll probably need to clean this out later to delete the stack.
    Type: String
    Default: codepipeline-kk-


Resources:

  # Amazon ECR Registry will hold our image after built / before deployed.
  ECRRepo:
    Type: AWS::ECR::Repository
    Properties: 
      RepositoryName: !Ref DockerImageName


  # This Role allows CodeBuild to do certain things on our behalf.
  # See the policy for the interesting stuff:
  CodeBuildRole:
    Type: AWS::IAM::Role
    Properties: 
      RoleName: !Sub ${AWS::StackName}-CodeBuildRole
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement: 
          Effect: Allow
          Principal:
            Service: codebuild.amazonaws.com
          Action: sts:AssumeRole

  # This Policy is attached to the CodeBuildRole.
  # CodeBuild is get and put on S3, CodeBuild, and CloudWatch Logs.  Allowed to login and push to ECR.  This all could probably be tightened quite a bit.
  CodeBuildPolicy:
    Type: AWS::IAM::Policy
    Properties: 
      PolicyName: !Sub ${AWS::StackName}--CodeBuildPolicy
      PolicyDocument: 
        Version: 2012-10-17
        Statement: 
          Effect: Allow
          Action: 
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
            - s3:putObject
            - s3:getObject
            - codebuild:*
            - ecr:Get*                    # For Docker builds pushing to ECR, one will need to GetAuthorizationToken
            - ecr:InitiateLayerUpload     # For Docker push to ECR
            - ecr:Upload*                 # For Docker push to ECR
            - ecr:Complete*               # For Docker push to ECR
          Resource: "*"
      Roles: 
        -  !Ref CodeBuildRole

  # This Role allows CodePipeline to make certain things on our behalf:
  # See the policy for the interesting stuff:
  CodePipelineRole:
    Type: AWS::IAM::Role
    Properties: 
      RoleName: !Sub ${AWS::StackName}-CodePipelineRole
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement: 
          Effect: Allow
          Principal:
            Service: codepipeline.amazonaws.com
          Action: sts:AssumeRole

  # This Policy is attached to the CodePipelineRole.
  # CodePipeline is allowed carte blanche on S3, CodeBuild, and CloudWatch Logs; could probably be tightened quite a bit.
  CodePipelinePolicy:
    Type: AWS::IAM::Policy
    Properties: 
      PolicyName: !Sub ${AWS::StackName}-CodePipelinePolicy
      PolicyDocument: 
        Version: 2012-10-17
        Statement: 
          Effect: Allow
          # Permissions are estimated based on what is automatically generated using the console.
          Action: 
            - s3:Get*
            - s3:PutObject
            - ec2:*
            - elasticloadbalancing:*
            - autoscaling:*
            - cloudwatch:*
            - elasticbeanstalk:*
            - cloudformation:*
            - s3:*
            - sns:*
            - sqs:*
            - codebuild:BatchGetBuilds
            - codebuild:StartBuild
            - iam:PassRole
          Resource: 
            - "*"
      Roles: 
        -  !Ref CodePipelineRole

  # This Role is given to the ElasticBeanstalk service to allow it to create environments:
  BeanstalkServiceRole:
    Type: AWS::IAM::Role
    Properties: 
      RoleName: !Sub ${AWS::StackName}-BeanstalkServiceRole  
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement: 
          Effect: Allow
          Principal:
            Service: elasticbeanstalk.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSElasticBeanstalkEnhancedHealth
        - arn:aws:iam::aws:policy/service-role/AWSElasticBeanstalkService

  # This Role allows the EC2 Instance created by Elastic Beanstalk to make ECR calls.
  BeanstalkInstanceRole:
    Type: AWS::IAM::Role
    Properties: 
      RoleName: !Sub ${AWS::StackName}-BeanstalkInstanceRole  
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement: 
          Effect: Allow
          Principal:
            Service: ec2.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/CloudWatchFullAccess
        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly

  # General Bucket where CodePipeline will store things:
  # Warning: This will need to be deleted manually before you can delete the stack.
  S3:
    Type: AWS::S3::Bucket
    Properties: 
      BucketName: !Sub ${CodePipelineBucketPrefix}${AWS::Region}

  # Build process for our Docker image
  DockerBuild:
    Type: AWS::CodeBuild::Project
    Properties: 
      Name: !Sub ${AWS::StackName}-DockerBuild
      Description: Docker image build + push
      ServiceRole: !Ref CodeBuildRole
      TimeoutInMinutes: 5
      Source:
        Type: CODEPIPELINE
        BuildSpec: !Sub |
            version: 0.2
            # This AWS CodeBuild buildspec runs a Docker build, plus push to ECR
            phases:
              pre_build:
                commands:
                  - # Show current version of CLI, Docker, etc.:
                  - aws --version
                  - docker --version
                  - echo Logging in to Amazon ECR...
                  - $(aws ecr get-login --region $AWS_DEFAULT_REGION --no-include-email)
                  - REPOSITORY_URI=${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${DockerImageName}
                  - echo REPOSITORY_URI is set to $REPOSITORY_URI
              build:
                commands:
                  - echo Building temporary image for testing on `date`
                  - docker build -f Dockerfile.dev -t test-image .
                  - echo Temporary image finished on `date`.  Starting test...
                  - docker run -e CI=true test-image npm run test -- --coverage
                  - echo Testing complete on `date`.  Building prod image...
                  - docker build -t $REPOSITORY_URI:latest .
                  - echo Prod image built on `date`.
              post_build:
                commands:
                  - echo Pushing the Docker images...
                  - docker push $REPOSITORY_URI:latest
                  - echo Creating the Dockerrun.aws.json file needed by ElasticBeanstalk
                  - printf '{"AWSEBDockerrunVersion":"1","Image":{"Name":"%s"},"Ports":[{"ContainerPort":80,"HostPort":80}]}' $REPOSITORY_URI:latest > Dockerrun.aws.json 
            artifacts:
                files: Dockerrun.aws.json
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/docker:17.09.0
      Artifacts:    
        Type: CODEPIPELINE


  # This is the CodePipeline with its stages:
  MyPipe:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      Name: !Sub ${AWS::StackName}-PipeFromGitHubToBeanstalk
      ArtifactStore: 
        Location: !Ref S3
        Type: S3
      RestartExecutionOnUpdate: true
      RoleArn: !GetAtt CodePipelineRole.Arn
      Stages: 

        # Stage 1:  Get the source from GitHub:
        - Name: Source
          Actions: 
            - Name: SourceAction
              RunOrder: 1
              ActionTypeId: 
                Category: Source
                Owner: ThirdParty 
                Provider: GitHub 
                Version: 1         # Required, meaningless and must be 1, go figure.
              Configuration: 
                Owner: !Select [0, !Split [ "/" , !Ref GitHubRepository ]]
                Repo: !Select [1, !Split [ "/" , !Ref GitHubRepository ]]
                Branch: !Select [2, !Split [ "/" , !Ref GitHubRepository ]]
                PollForSourceChanges: true   # Don't know if/how to control frequency
                OAuthToken: !Ref GitHubOAuthToken     # Public repository, Don't know why AWS needs this
              OutputArtifacts: 
                - Name: TheSourceCode

        # Stage 2:  Build using CodeBuild / Maven, Test in parallel using CodeBuild / Maven:
        - Name: Build
          Actions:
            # This runs a Maven build which packages the WAR.  Test are run in the parallel action below: 
            - Name: MavenBuild
              RunOrder: 1
              InputArtifacts: 
                - Name: TheSourceCode           # Duh, the output from the previous step.
              ActionTypeId: 
                Category: Build
                Owner: AWS       
                Provider: CodeBuild        
                Version: 1                      # Required, meaningless and must be 1.
              Configuration:
                ProjectName:  !Ref DockerBuild  # See the CodeBuild definition above. 
              OutputArtifacts: 
                - Name: TheDockerrunAwsJson     # A little JSON file that tells Beanstalk the image to run

        # Stage 3:  Deploy on ElasticBeanstalk:
        - Name: Deploy
          Actions:
            # This Deploys on ElasticBeanstalk so we can quickly smoke-test the running app: 
            - Name: Deploy
              RunOrder: 1
              InputArtifacts: 
                - Name: TheDockerrunAwsJson         # Duh, the output from the previous step.
              ActionTypeId: 
                Category: Deploy
                Owner: AWS       
                Provider: ElasticBeanstalk        
                Version: 1                  # Don't know the purpose of 'version'.  Required and can only be 1.
              Configuration:
                ApplicationName:  !Ref MyBeanstalkApplication  # See the EB definition below.       
                EnvironmentName:  !Ref MyBeanstalkEnvironment  # See the EB definition below.       
 

  MyBeanstalkApplication:
    Type: AWS::ElasticBeanstalk::Application
    Properties:
      ApplicationName: docker-react
      Description: Quick live-test environment for the app.

  MyBeanstalkEnvironment:
    Type: AWS::ElasticBeanstalk::Environment
    Properties:
      ApplicationName: !Ref MyBeanstalkApplication
      EnvironmentName: docker-react
      Description: Quick live-test environment for the app.
      CNAMEPrefix: docker-react                         # This will become part of the DNS name.  Probably shouldn't be hard-coded.
      SolutionStackName: "64bit Amazon Linux 2018.03 v2.12.11 running Docker 18.06.1-ce"
      OptionSettings: 
        - Namespace: aws:elasticbeanstalk:application
          OptionName: "Application Healthcheck URL"
          Value: /

        - Namespace: aws:elasticbeanstalk:environment
          OptionName: ServiceRole
          Value: !Ref BeanstalkServiceRole

        - Namespace: aws:autoscaling:launchconfiguration
          OptionName: IamInstanceProfile
          Value: !Ref EBInstanceProfile

  EBInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties: 
      InstanceProfileName: !Sub ${AWS::StackName}-InstanceProfile
      Roles: [!Ref BeanstalkInstanceRole ]

Outputs:
  CodePipeline:
    Value: !Sub https://${AWS::Region}.console.aws.amazon.com/codesuite/codepipeline/pipelines/${MyPipe}/view

  RepositoryURI:
    Value:  !Sub ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${DockerImageName}
    Description:  Docker image URI as stored in AWS ECR.